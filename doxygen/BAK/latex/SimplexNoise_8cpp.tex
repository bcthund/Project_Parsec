\hypertarget{SimplexNoise_8cpp}{}\doxysection{src/headers/core/\+Simplex\+Noise.cpp File Reference}
\label{SimplexNoise_8cpp}\index{src/headers/core/SimplexNoise.cpp@{src/headers/core/SimplexNoise.cpp}}


A Perlin Simplex Noise C++ Implementation (1D, 2D, 3D).  


{\ttfamily \#include \char`\"{}Simplex\+Noise.\+h\char`\"{}}\newline
{\ttfamily \#include $<$cstdint$>$}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int32\+\_\+t \mbox{\hyperlink{SimplexNoise_8cpp_ac357795e5f54b15183807d99cde5199d}{fastfloor}} (float fp)
\item 
static uint8\+\_\+t \mbox{\hyperlink{SimplexNoise_8cpp_a39b91b979c2d169ec26079a983134a54}{hash}} (int32\+\_\+t i)
\item 
static float \mbox{\hyperlink{SimplexNoise_8cpp_a70932d9c87977053f493d729e778e661}{grad}} (int32\+\_\+t \mbox{\hyperlink{SimplexNoise_8cpp_a39b91b979c2d169ec26079a983134a54}{hash}}, float \mbox{\hyperlink{gl4__5_2glcorearb_8h_a0cdec8e97a75ee9458b23d152bf962d4}{x}})
\item 
static float \mbox{\hyperlink{SimplexNoise_8cpp_a944a4d8f19534304e5d0192670da10b2}{grad}} (int32\+\_\+t \mbox{\hyperlink{SimplexNoise_8cpp_a39b91b979c2d169ec26079a983134a54}{hash}}, float \mbox{\hyperlink{gl4__5_2glcorearb_8h_a0cdec8e97a75ee9458b23d152bf962d4}{x}}, float \mbox{\hyperlink{gl4__5_2glcorearb_8h_a74d80fd479c0f6d0153c709949a089ef}{y}})
\item 
static float \mbox{\hyperlink{SimplexNoise_8cpp_a6f1acf5d562d1ab1bdbe7e4292cabb9c}{grad}} (int32\+\_\+t \mbox{\hyperlink{SimplexNoise_8cpp_a39b91b979c2d169ec26079a983134a54}{hash}}, float \mbox{\hyperlink{gl4__5_2glcorearb_8h_a0cdec8e97a75ee9458b23d152bf962d4}{x}}, float \mbox{\hyperlink{gl4__5_2glcorearb_8h_a74d80fd479c0f6d0153c709949a089ef}{y}}, float \mbox{\hyperlink{gl4__5_2glcorearb_8h_aee38b51639b577753f6a92029fb92000}{z}})
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static const uint8\+\_\+t \mbox{\hyperlink{SimplexNoise_8cpp_a1587ac10c84c0df57701797b751eddda}{perm}} \mbox{[}256\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A Perlin Simplex Noise C++ Implementation (1D, 2D, 3D). 

Copyright (c) 2014-\/2018 Sebastien Rombauts (\href{mailto:sebastien.rombauts@gmail.com}{\texttt{ sebastien.\+rombauts@gmail.\+com}})

This C++ implementation is based on the speed-\/improved Java version 2012-\/03-\/09 by Stefan Gustavson (original Java source code in the public domain). \href{http://webstaff.itn.liu.se/~stegu/simplexnoise/SimplexNoise.java:}{\texttt{ http\+://webstaff.\+itn.\+liu.\+se/$\sim$stegu/simplexnoise/\+Simplex\+Noise.\+java\+:}}
\begin{DoxyItemize}
\item Based on example code by Stefan Gustavson (\href{mailto:stegu@itn.liu.se}{\texttt{ stegu@itn.\+liu.\+se}}).
\item Optimisations by Peter Eastman (\href{mailto:peastman@drizzle.stanford.edu}{\texttt{ peastman@drizzle.\+stanford.\+edu}}).
\item Better rank ordering method by Stefan Gustavson in 2012.
\end{DoxyItemize}

This implementation is \char`\"{}\+Simplex Noise\char`\"{} as presented by Ken Perlin at a relatively obscure and not often cited course session \char`\"{}\+Real-\/\+Time Shading\char`\"{} at Siggraph 2001 (before real time shading actually took on), under the title \char`\"{}hardware noise\char`\"{}. The 3D function is numerically equivalent to his Java reference code available in the P\+DF course notes, although I re-\/implemented it from scratch to get more readable code. The 1D, 2D and 4D cases were implemented from scratch by me from Ken Perlin\textquotesingle{}s text.

Distributed under the M\+IT License (M\+IT) (See accompanying file L\+I\+C\+E\+N\+S\+E.\+txt or copy at \href{http://opensource.org/licenses/MIT}{\texttt{ http\+://opensource.\+org/licenses/\+M\+IT}}) 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{SimplexNoise_8cpp_ac357795e5f54b15183807d99cde5199d}\label{SimplexNoise_8cpp_ac357795e5f54b15183807d99cde5199d}} 
\index{SimplexNoise.cpp@{SimplexNoise.cpp}!fastfloor@{fastfloor}}
\index{fastfloor@{fastfloor}!SimplexNoise.cpp@{SimplexNoise.cpp}}
\doxysubsubsection{\texorpdfstring{fastfloor()}{fastfloor()}}
{\footnotesize\ttfamily static int32\+\_\+t fastfloor (\begin{DoxyParamCaption}\item[{float}]{fp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Computes the largest integer value not greater than the float one

This method is faster than using (int32\+\_\+t)std\+::floor(fp).

I measured it to be approximately twice as fast\+: float\+: $\sim$18.4ns instead of $\sim$39.6ns on an A\+MD A\+PU), double\+: $\sim$20.6ns instead of $\sim$36.6ns on an A\+MD A\+PU), Reference\+: \href{http://www.codeproject.com/Tips/700780/Fast-floor-ceiling-functions}{\texttt{ http\+://www.\+codeproject.\+com/\+Tips/700780/\+Fast-\/floor-\/ceiling-\/functions}}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fp} & float input value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
largest integer value not greater than fp 
\end{DoxyReturn}


Definition at line 45 of file Simplex\+Noise.\+cpp.



Referenced by Simplex\+Noise\+::noise().

\mbox{\Hypertarget{SimplexNoise_8cpp_a70932d9c87977053f493d729e778e661}\label{SimplexNoise_8cpp_a70932d9c87977053f493d729e778e661}} 
\index{SimplexNoise.cpp@{SimplexNoise.cpp}!grad@{grad}}
\index{grad@{grad}!SimplexNoise.cpp@{SimplexNoise.cpp}}
\doxysubsubsection{\texorpdfstring{grad()}{grad()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static float grad (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{hash,  }\item[{float}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Helper function to compute gradients-\/dot-\/residual vectors (1D)

\begin{DoxyNote}{Note}
that these generate gradients of more than unit length. To make a close match with the value range of classic Perlin noise, the final noise values need to be rescaled to fit nicely within \mbox{[}-\/1,1\mbox{]}. (The simplex noise functions as such also have different scaling.) Note also that these noise functions are the most practical and useful signed version of Perlin noise.
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em hash} & hash value \\
\hline
\mbox{\texttt{ in}}  & {\em x} & distance to the corner\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
gradient value 
\end{DoxyReturn}


Definition at line 125 of file Simplex\+Noise.\+cpp.



References hash().



Referenced by Simplex\+Noise\+::noise().

\mbox{\Hypertarget{SimplexNoise_8cpp_a944a4d8f19534304e5d0192670da10b2}\label{SimplexNoise_8cpp_a944a4d8f19534304e5d0192670da10b2}} 
\index{SimplexNoise.cpp@{SimplexNoise.cpp}!grad@{grad}}
\index{grad@{grad}!SimplexNoise.cpp@{SimplexNoise.cpp}}
\doxysubsubsection{\texorpdfstring{grad()}{grad()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static float grad (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{hash,  }\item[{float}]{x,  }\item[{float}]{y }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Helper functions to compute gradients-\/dot-\/residual vectors (2D)


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em hash} & hash value \\
\hline
\mbox{\texttt{ in}}  & {\em x} & x coord of the distance to the corner \\
\hline
\mbox{\texttt{ in}}  & {\em y} & y coord of the distance to the corner\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
gradient value 
\end{DoxyReturn}


Definition at line 142 of file Simplex\+Noise.\+cpp.



References hash(), x, and y.

\mbox{\Hypertarget{SimplexNoise_8cpp_a6f1acf5d562d1ab1bdbe7e4292cabb9c}\label{SimplexNoise_8cpp_a6f1acf5d562d1ab1bdbe7e4292cabb9c}} 
\index{SimplexNoise.cpp@{SimplexNoise.cpp}!grad@{grad}}
\index{grad@{grad}!SimplexNoise.cpp@{SimplexNoise.cpp}}
\doxysubsubsection{\texorpdfstring{grad()}{grad()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static float grad (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{hash,  }\item[{float}]{x,  }\item[{float}]{y,  }\item[{float}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Helper functions to compute gradients-\/dot-\/residual vectors (3D)


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em hash} & hash value \\
\hline
\mbox{\texttt{ in}}  & {\em x} & x coord of the distance to the corner \\
\hline
\mbox{\texttt{ in}}  & {\em y} & y coord of the distance to the corner \\
\hline
\mbox{\texttt{ in}}  & {\em z} & z coord of the distance to the corner\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
gradient value 
\end{DoxyReturn}


Definition at line 159 of file Simplex\+Noise.\+cpp.



References hash(), x, y, and z.

\mbox{\Hypertarget{SimplexNoise_8cpp_a39b91b979c2d169ec26079a983134a54}\label{SimplexNoise_8cpp_a39b91b979c2d169ec26079a983134a54}} 
\index{SimplexNoise.cpp@{SimplexNoise.cpp}!hash@{hash}}
\index{hash@{hash}!SimplexNoise.cpp@{SimplexNoise.cpp}}
\doxysubsubsection{\texorpdfstring{hash()}{hash()}}
{\footnotesize\ttfamily static uint8\+\_\+t hash (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Helper function to hash an integer using the above permutation table

This inline function costs around 1ns, and is called N+1 times for a noise of N dimension.

Using a real hash function would be better to improve the \char`\"{}repeatability of 256\char`\"{} of the above permutation table, but fast integer Hash functions uses more time and have bad random properties.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i} & Integer value to hash\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
8-\/bits hashed value 
\end{DoxyReturn}


Definition at line 99 of file Simplex\+Noise.\+cpp.



References perm.



Referenced by grad(), and Simplex\+Noise\+::noise().



\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{SimplexNoise_8cpp_a1587ac10c84c0df57701797b751eddda}\label{SimplexNoise_8cpp_a1587ac10c84c0df57701797b751eddda}} 
\index{SimplexNoise.cpp@{SimplexNoise.cpp}!perm@{perm}}
\index{perm@{perm}!SimplexNoise.cpp@{SimplexNoise.cpp}}
\doxysubsubsection{\texorpdfstring{perm}{perm}}
{\footnotesize\ttfamily const uint8\+\_\+t perm\mbox{[}256\mbox{]}\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{= \{}
\DoxyCodeLine{    151, 160, 137, 91, 90, 15,}
\DoxyCodeLine{    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,}
\DoxyCodeLine{    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,}
\DoxyCodeLine{    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,}
\DoxyCodeLine{    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,}
\DoxyCodeLine{    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,}
\DoxyCodeLine{    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,}
\DoxyCodeLine{    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,}
\DoxyCodeLine{    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,}
\DoxyCodeLine{    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,}
\DoxyCodeLine{    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,}
\DoxyCodeLine{    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,}
\DoxyCodeLine{    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180}
\DoxyCodeLine{\}}

\end{DoxyCode}
Permutation table. This is just a random jumble of all numbers 0-\/255.

This produce a repeatable pattern of 256, but Ken Perlin stated that it is not a problem for graphic texture as the noise features disappear at a distance far enough to be able to see a repeatable pattern of 256.

This needs to be exactly the same for all instances on all platforms, so it\textquotesingle{}s easiest to just keep it as static explicit data. This also removes the need for any initialisation of this class.

Note that making this an uint32\+\_\+t\mbox{[}\mbox{]} instead of a uint8\+\_\+t\mbox{[}\mbox{]} might make the code run faster on platforms with a high penalty for unaligned single byte addressing. Intel x86 is generally single-\/byte-\/friendly, but some other C\+P\+Us are faster with 4-\/aligned reads. However, a char\mbox{[}\mbox{]} is smaller, which avoids cache trashing, and that is probably the most important aspect on most architectures. This array is accessed a {\itshape lot} by the noise functions. A vector-\/valued noise over 3D accesses it 96 times, and a float-\/valued 4D noise 64 times. We want this to fit in the cache! 

Definition at line 71 of file Simplex\+Noise.\+cpp.



Referenced by hash().

